<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="theme-color" content="#1a1a2e" />
    <meta name="description" content="PDF Position Detector - Optimized for Thai Language" />
    <title>PDF Position Detector - Thai Optimized</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Sarabun:wght@300;400;600&family=Noto+Sans+Thai:wght@300;400;600&display=swap" rel="stylesheet">
    
    <style>
        :root { --bg-primary:#fff; --bg-secondary:#f8f9fa; --bg-tertiary:#e9ecef; --text-primary:#212529; --accent:#4361ee; --border:#dee2e6; --radius:8px; --transition:.3s; --success:#2ecc71; --warning:#f39c12; --danger:#e74c3c; }
        [data-theme="dark"] { --bg-primary:#1a1a2e; --bg-secondary:#16213e; --bg-tertiary:#0f3460; --text-primary:#e9ecef; --accent:#4cc9f0; --border:#3d5a80; }
        * { box-sizing:border-box; margin:0; padding:0; }
        body { font-family: 'Sarabun', 'Noto Sans Thai', sans-serif; background:var(--bg-primary); color:var(--text-primary); min-height:100vh; }
        .app-container { display:flex; flex-direction:column; min-height:100vh; }
        header { background:var(--bg-secondary); padding:1rem 1.5rem; display:flex; justify-content:space-between; align-items:center; border-bottom:1px solid var(--border); }
        .logo { display:flex; gap:.5rem; align-items:center; font-weight:700; color:var(--accent); }
        main { display:flex; gap:1rem; padding:1rem; height:calc(100vh - 80px); overflow:hidden; }
        .sidebar { width:320px; background:var(--bg-secondary); border-radius:var(--radius); padding:1rem; display:flex; flex-direction:column; gap:1rem; overflow:auto; }
        .panel { background:var(--bg-primary); border:1px solid var(--border); border-radius:var(--radius); padding:1rem; }
        .upload-zone { border:2px dashed var(--border); border-radius:var(--radius); padding:2rem; text-align:center; cursor:pointer; transition:all .3s; }
        .upload-zone:hover, .upload-zone.dragover { background:var(--bg-tertiary); border-color:var(--accent); }
        .viewer-container { flex:1; background:var(--bg-secondary); border-radius:var(--radius); display:flex; flex-direction:column; overflow:hidden; position:relative; }
        .viewer-canvas-wrapper { flex:1; overflow:auto; display:flex; align-items:flex-start; justify-content:center; padding:2rem; background:var(--bg-primary); }
        .canvas-container { position:relative; box-shadow:0 4px 20px rgba(0,0,0,0.1); margin:auto; }
        #pdfCanvas { display:block; background:white; position:relative; z-index:1; }
        #overlayCanvas { position:absolute; top:0; left:0; pointer-events:none; z-index:2; }
        #overlayCanvas.drawing { pointer-events:auto; cursor:crosshair; }
        .results-panel { width:350px; background:var(--bg-secondary); border-radius:var(--radius); padding:1rem; display:flex; flex-direction:column; gap:1rem; overflow:auto; }
        .code-output { background:#1e1e1e; color:#d4d4d4; padding:1rem; border-radius:8px; font-family:monospace; font-size:.8rem; max-height:240px; overflow:auto; white-space:pre-wrap; }
        .toast { position:fixed; bottom:2rem; right:2rem; padding:1rem 1.5rem; background:var(--bg-secondary); border:1px solid var(--border); border-radius:8px; transform:translateY(150%); transition:transform .3s; z-index:1000; box-shadow:0 4px 12px rgba(0,0,0,0.15); }
        .toast.show { transform:translateY(0); }
        .loading-overlay { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,0.5); z-index:1001; opacity:0; visibility:hidden; transition:all .3s; }
        .loading-overlay.show { opacity:1; visibility:visible; }
        footer { background:var(--bg-secondary); padding:.5rem 1rem; text-align:center; border-top:1px solid var(--border); font-size:.75rem; color:#666; }
        @media (max-width:1024px) { main { flex-direction:column; height:auto; } .sidebar, .results-panel { width:100%; max-height:500px; } }
        
        button { padding:.5rem 1rem; border:1px solid var(--border); background:var(--bg-secondary); color:var(--text-primary); border-radius:4px; cursor:pointer; font-family:inherit; transition:all .2s; }
        button:hover { background:var(--bg-tertiary); transform:translateY(-1px); }
        button.active { background:var(--accent); color:white; border-color:var(--accent); }
        .tab { padding:.4rem .8rem; font-size:.9rem; }
        .progress-bar { width:100%; height:4px; background:var(--bg-tertiary); border-radius:2px; overflow:hidden; }
        .progress-bar-fill { height:100%; background:var(--accent); transition:width .3s; }
        .thai-font-info { font-size:.85rem; color:#666; margin-top:.5rem; padding:.5rem; background:var(--bg-tertiary); border-radius:4px; }
        /* Fix Checkbox alignment */
        .option-row { display: flex; align-items: center; gap: 8px; margin-top: 5px; font-size: 0.9rem; }
    </style>
</head>
<body>
    <div class="app-container">
        <header>
            <div class="logo">
                <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline></svg>
                PDF Position Detector (Thai Optimized)
            </div>
            <div><button id="themeToggle">Theme</button></div>
        </header>

        <main>
            <aside class="sidebar">
                <div class="panel">
                    <h3>‡∏≠‡∏±‡∏û‡πÇ‡∏´‡∏•‡∏î PDF</h3>
                    <div id="uploadZone" class="upload-zone" role="button" tabindex="0">‡∏Ñ‡∏•‡∏¥‡∏Å‡∏´‡∏£‡∏∑‡∏≠‡∏•‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå PDF ‡∏°‡∏≤‡∏ß‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà<br/><small>‡∏Ç‡∏ô‡∏≤‡∏î‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î 5MB</small></div>
                    <input id="fileInput" type="file" accept=".pdf" style="display:none" />
                    <div id="uploadProgress" class="progress-bar" style="display:none; margin-top:.75rem;">
                        <div class="progress-bar-fill" style="width:0%"></div>
                    </div>
                </div>

                <div class="panel" id="pageControlPanel" style="display:none;">
                    <h3>‡∏Å‡∏≤‡∏£‡∏ô‡∏≥‡∏ó‡∏≤‡∏á</h3>
                    <div style="display:flex; gap:.5rem; align-items:center;">
                        <button id="prevPage">‚óÄ</button>
                        <input id="pageInput" type="number" value="1" min="1" style="width:60px; padding:.3rem;" />
                        <span>/ <span id="totalPages">1</span></span>
                        <button id="nextPage">‚ñ∂</button>
                    </div>
                </div>

                <div class="panel" id="methodPanel" style="display:none;">
                    <h3>‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠</h3>
                    <div style="display:flex; flex-direction:column; gap:.5rem;">
                        <button id="runAllMethods" class="active">‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥ (Auto)</button>
                        <button id="methodManual">‡∏•‡∏≤‡∏Å‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏≠‡∏á (Manual)</button>
                    </div>
                    
                    <div class="thai-font-info">
                        <strong>‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢:</strong>
                        <div class="option-row">
                            <input type="checkbox" id="optSplitColon" checked>
                            <label for="optSplitColon">‡πÅ‡∏¢‡∏Å‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢ Colon (:)</label>
                        </div>
                        <div class="option-row">
                            <input type="checkbox" id="optMergeVowels" checked>
                            <label for="optMergeVowels">‡∏£‡∏ß‡∏°‡∏™‡∏£‡∏∞‡∏•‡∏≠‡∏¢/‡∏ß‡∏£‡∏£‡∏ì‡∏¢‡∏∏‡∏Å‡∏ï‡πå</label>
                        </div>
                    </div>
                </div>
            </aside>

            <div class="viewer-container">
                <div id="viewerToolbar" style="display:none; padding:.75rem; border-bottom:1px solid var(--border); background:var(--bg-tertiary);">
                    <div style="display:flex; gap:.5rem; align-items:center;">
                        <button id="zoomOut">‚àí</button>
                        <input id="zoomRange" type="range" min="50" max="200" value="100" />
                        <button id="zoomIn">+</button>
                        <span id="zoomLevel">100%</span>
                    </div>
                </div>

                <div class="viewer-canvas-wrapper">
                    <div id="emptyState" style="text-align:center; color:#888;">
                        <h3>‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÑ‡∏ü‡∏•‡πå</h3>
                        <p>‡∏≠‡∏±‡∏û‡πÇ‡∏´‡∏•‡∏î PDF ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô</p>
                    </div>

                    <div id="canvasContainer" class="canvas-container" style="display:none;">
                        <canvas id="pdfCanvas"></canvas>
                        <canvas id="overlayCanvas"></canvas>
                    </div>
                </div>
            </div>

            <aside class="results-panel" id="resultsPanel" style="display:none;">
                <div class="panel">
                    <h3>‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå (‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£)</h3>
                    <div id="resultsContainer"></div>
                </div>

                <div class="panel" id="outputPanel" style="display:none;">
                    <h3>Export Code</h3>
                    <div style="display:flex; gap:.5rem; margin-bottom:.5rem;">
                        <button class="tab active" data-tab="html">HTML</button>
                        <button class="tab" data-tab="full">Full Page</button>
                    </div>
                    <div id="codeOutput" class="code-output"></div>
                    <div style="display:flex; gap:.5rem; margin-top:.5rem;">
                        <button id="copyBtn" style="flex:1;">‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å</button>
                        <button id="downloadBtn">‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î</button>
                    </div>
                </div>
            </aside>
        </main>

        <footer>PDF Position Detector v2.2 | Optimized for Thai Language by Gemini</footer>
    </div>

    <div id="loadingOverlay" class="loading-overlay">
        <div style="width:48px;height:48px;border:4px solid #eee;border-top-color:var(--accent);border-radius:50%;animation:spin 1s linear infinite"></div>
    </div>
    <div id="toast" class="toast"><span id="toastMessage"></span></div>

    <style>@keyframes spin { to { transform: rotate(360deg); } }</style>

    <script>
    // --- Configuration ---
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

    const state = {
        pdfDoc: null, currentPage: 1, totalPages: 0, zoom: 1,
        results: [], isManualMode: false, manualSelection: null, renderTask: null,
        devicePixelRatio: window.devicePixelRatio || 1, currentTab: 'html',
        theme: localStorage.getItem('theme') || 'light'
    };

    const el = (id) => document.getElementById(id);
    const elements = {
        uploadZone: el('uploadZone'), fileInput: el('fileInput'), uploadProgress: el('uploadProgress'),
        pageControlPanel: el('pageControlPanel'), methodPanel: el('methodPanel'),
        viewerToolbar: el('viewerToolbar'), emptyState: el('emptyState'),
        canvasContainer: el('canvasContainer'), pdfCanvas: el('pdfCanvas'), overlayCanvas: el('overlayCanvas'),
        resultsPanel: el('resultsPanel'), resultsContainer: el('resultsContainer'),
        outputPanel: el('outputPanel'), codeOutput: el('codeOutput'),
        loadingOverlay: el('loadingOverlay'), toast: el('toast'), toastMessage: el('toastMessage'),
        themeToggle: el('themeToggle'), pageInput: el('pageInput'), totalPagesSpan: el('totalPages'),
        prevPage: el('prevPage'), nextPage: el('nextPage'),
        zoomRange: el('zoomRange'), zoomLevel: el('zoomLevel'), zoomIn: el('zoomIn'), zoomOut: el('zoomOut'),
        runAllMethods: el('runAllMethods'), methodManual: el('methodManual'),
        copyBtn: el('copyBtn'), downloadBtn: el('downloadBtn'),
        optSplitColon: el('optSplitColon'), optMergeVowels: el('optMergeVowels')
    };

    // --- Helper Functions ---
    function showLoading(){ elements.loadingOverlay.classList.add('show'); document.body.style.cursor = 'wait'; }
    function hideLoading(){ elements.loadingOverlay.classList.remove('show'); document.body.style.cursor = 'default'; }
    function showToast(msg, type='success'){
        elements.toastMessage.textContent = msg;
        elements.toast.className = `toast ${type}`;
        elements.toast.classList.add('show');
        setTimeout(() => elements.toast.classList.remove('show'), 3000);
    }
    function escapeHtml(s){ return s.replace(/[&<>"']/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[m])); }

    // --- Theme Logic ---
    function applyTheme(theme) {
        state.theme = theme;
        document.documentElement.setAttribute('data-theme', theme);
        localStorage.setItem('theme', theme);
        elements.themeToggle.textContent = theme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
    }
    applyTheme(state.theme);
    elements.themeToggle.addEventListener('click', () => applyTheme(state.theme === 'dark' ? 'light' : 'dark'));

    // --- PDF Loading & Rendering ---
    elements.uploadZone.addEventListener('click', () => elements.fileInput.click());
    elements.uploadZone.addEventListener('dragover', (e) => { e.preventDefault(); elements.uploadZone.classList.add('dragover'); });
    elements.uploadZone.addEventListener('dragleave', () => elements.uploadZone.classList.remove('dragover'));
    elements.uploadZone.addEventListener('drop', async (e) => {
        e.preventDefault(); elements.uploadZone.classList.remove('dragover');
        if (e.dataTransfer.files[0]) await handleFile(e.dataTransfer.files[0]);
    });
    elements.fileInput.addEventListener('change', async (e) => { if (e.target.files[0]) await handleFile(e.target.files[0]); });

    async function handleFile(file) {
        if (!file || !file.name.toLowerCase().endsWith('.pdf')) return showToast('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå PDF ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô', 'error');
        showLoading();
        elements.uploadProgress.style.display = 'block';
        try {
            if (state.pdfDoc) { try { await state.pdfDoc.destroy(); } catch(e){} }
            const arrayBuffer = await file.arrayBuffer();
            const loadingTask = pdfjsLib.getDocument({ 
                data: new Uint8Array(arrayBuffer), 
                cMapUrl: 'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/cmaps/', 
                cMapPacked: true 
            });
            loadingTask.onProgress = (p) => { if(p.total > 0) elements.uploadProgress.querySelector('.progress-bar-fill').style.width = Math.round((p.loaded/p.total)*100) + '%'; };
            state.pdfDoc = await loadingTask.promise;
            state.totalPages = state.pdfDoc.numPages;
            state.currentPage = 1;
            elements.totalPagesSpan.textContent = state.totalPages;
            elements.pageInput.value = 1; elements.pageInput.max = state.totalPages;
            
            showPdfUI(); 
            await renderPage(state.currentPage);
            showToast(`‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à (${state.totalPages} ‡∏´‡∏ô‡πâ‡∏≤)`, 'success');
        } catch (err) { showToast('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ' + err.message, 'error'); } 
        finally { hideLoading(); elements.uploadProgress.style.display = 'none'; }
    }

    function showPdfUI() {
        elements.emptyState.style.display = 'none'; elements.canvasContainer.style.display = 'block';
        elements.pageControlPanel.style.display = 'block'; elements.methodPanel.style.display = 'block';
        elements.viewerToolbar.style.display = 'flex'; elements.resultsPanel.style.display = 'flex';
        state.results = []; elements.resultsContainer.innerHTML = ''; elements.outputPanel.style.display = 'none';
    }

    async function renderPage(pageNum) {
        if (!state.pdfDoc) return;
        if (state.renderTask) { try { state.renderTask.cancel(); } catch(e){} }
        showLoading();
        try {
            const page = await state.pdfDoc.getPage(pageNum);
            const viewport = page.getViewport({ scale: state.zoom });
            
            // Resize Canvas
            const canvas = elements.pdfCanvas;
            const overlay = elements.overlayCanvas;
            const ratio = state.devicePixelRatio;
            
            canvas.style.width = Math.floor(viewport.width) + 'px';
            canvas.style.height = Math.floor(viewport.height) + 'px';
            canvas.width = Math.floor(viewport.width * ratio);
            canvas.height = Math.floor(viewport.height * ratio);
            
            overlay.style.width = canvas.style.width;
            overlay.style.height = canvas.style.height;
            overlay.width = canvas.width;
            overlay.height = canvas.height;

            const ctx = canvas.getContext('2d');
            ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
            
            state.renderTask = page.render({ canvasContext: ctx, viewport: viewport });
            await state.renderTask.promise;
            
            // Re-draw overlay if results exist
            drawOverlay();
        } catch (err) { if (err?.name !== 'RenderingCancelledException') console.error(err); } 
        finally { hideLoading(); }
    }

    // --- Analysis Logic (THE CORE FIX) ---
    async function extractAndMergeText() {
        if (!state.pdfDoc) return;
        showLoading();
        try {
            const page = await state.pdfDoc.getPage(state.currentPage);
            const textContent = await page.getTextContent();
            const viewport = page.getViewport({ scale: 1 }); // Base scale for coords

            let items = textContent.items.map(item => {
                // PDF coords to Viewport coords
                // transform: [scaleX, skewY, skewX, scaleY, transX, transY]
                const tx = pdfjsLib.Util.transform(viewport.transform, item.transform);
                const fontHeight = Math.sqrt((tx[2] * tx[2]) + (tx[3] * tx[3]));
                
                // Calculate width/height
                const width = item.width * (fontHeight / item.height * Math.abs(item.transform[3]) || 1); // Approx
                
                // Normalize Box (PDF.js y is bottom-up, need top-down)
                // We use standard viewport conversion for reliability
                const rect = viewport.convertToViewportRectangle([
                    item.transform[4], 
                    item.transform[5], 
                    item.transform[4] + item.width, 
                    item.transform[5] + (item.height || fontHeight)
                ]);
                
                const x = Math.min(rect[0], rect[2]);
                const y = Math.min(rect[1], rect[3]);
                const w = Math.abs(rect[2] - rect[0]);
                const h = Math.abs(rect[3] - rect[1]);

                return {
                    text: item.str,
                    box: { x, y, w, h },
                    fontHeight: h
                };
            }).filter(i => i.text.trim().length > 0);

            // Sort: Top->Bottom, Left->Right
            items.sort((a, b) => {
                const yDiff = Math.abs(a.box.y - b.box.y);
                if (yDiff < 5) return a.box.x - b.box.x; 
                return a.box.y - b.box.y;
            });

            // Merging Logic
            const merged = [];
            let current = null;
            
            // Regex for Thai Marks (Upper/Lower)
            const reUpper = /[\u0E31\u0E34-\u0E3A\u0E47-\u0E4E]/;
            const reLower = /[\u0E38-\u0E39]/;
            const reThai = /[\u0E00-\u0E7F]/;

            for (const item of items) {
                if (!current) {
                    current = JSON.parse(JSON.stringify(item));
                    continue;
                }

                // Calculate Gaps
                const yDiff = Math.abs(current.box.y - item.box.y);
                const xGap = item.box.x - (current.box.x + current.box.w);
                
                // Logic switches
                const isColon = (t) => t.includes(':');
                const isThaiMark = reUpper.test(item.text) || reLower.test(item.text);
                const isCurrentThai = reThai.test(current.text);

                // 1. Check if same line (visually)
                let isSameLine = yDiff < (current.box.h * 0.7);
                
                // 2. Vertical Overlap Check (Specific for Thai Tone Marks being "above")
                // If the new item is a mark, and overlaps horizontally with current, force merge
                if (elements.optMergeVowels.checked && isThaiMark && isCurrentThai) {
                    const xOverlap = (item.box.x < current.box.x + current.box.w) && (item.box.x + item.box.w > current.box.x);
                    if (xOverlap) {
                        isSameLine = true; // Force same line logic
                    }
                }

                let shouldMerge = false;
                
                if (isSameLine) {
                    // Check Colon Splitting
                    if (elements.optSplitColon.checked && (isColon(current.text) || isColon(item.text))) {
                        shouldMerge = false;
                    } 
                    // Normal Merge (Small X Gap) or Overlap (Negative Gap)
                    else if (xGap < 15) { // 15px tolerance
                        shouldMerge = true;
                    }
                }

                if (shouldMerge) {
                    current.text += item.text;
                    // Expand Box
                    const newX = Math.min(current.box.x, item.box.x);
                    const newY = Math.min(current.box.y, item.box.y); // Take highest point
                    const newRight = Math.max(current.box.x + current.box.w, item.box.x + item.box.w);
                    const newBottom = Math.max(current.box.y + current.box.h, item.box.y + item.box.h);
                    
                    current.box.x = newX;
                    current.box.y = newY;
                    current.box.w = newRight - newX;
                    current.box.h = newBottom - newY;
                    current.fontHeight = Math.max(current.fontHeight, item.fontHeight);
                } else {
                    merged.push(current);
                    current = JSON.parse(JSON.stringify(item));
                }
            }
            if (current) merged.push(current);

            state.results = merged;
            updateUIResults();
            showToast(`‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô: ${merged.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£`);

        } catch (e) { console.error(e); showToast('Error: ' + e.message, 'error'); }
        finally { hideLoading(); }
    }

    elements.runAllMethods.addEventListener('click', extractAndMergeText);

    // --- Visualization & Output ---
    function drawOverlay() {
        const ctx = elements.overlayCanvas.getContext('2d');
        const ratio = state.devicePixelRatio;
        const zoom = state.zoom;
        
        ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
        ctx.clearRect(0, 0, elements.overlayCanvas.width/ratio, elements.overlayCanvas.height/ratio);

        // Draw Extracted Boxes
        state.results.forEach(item => {
            const b = item.box;
            const x = b.x * zoom, y = b.y * zoom, w = b.w * zoom, h = b.h * zoom;
            
            ctx.fillStyle = 'rgba(67,97,238,0.1)';
            ctx.fillRect(x, y, w, h);
            ctx.strokeStyle = '#4361ee';
            ctx.lineWidth = 1;
            ctx.strokeRect(x, y, w, h);
        });

        // Manual Selection
        if (state.isManualMode && state.manualSelection) {
            const sel = state.manualSelection;
            ctx.strokeStyle = '#2ecc71'; ctx.setLineDash([5, 3]); ctx.lineWidth = 2;
            ctx.strokeRect(sel.x, sel.y, sel.w, sel.h); ctx.setLineDash([]);
        }
    }

    function updateUIResults() {
        drawOverlay();
        
        // List View
        elements.resultsContainer.innerHTML = '';
        state.results.forEach((item, idx) => {
            const div = document.createElement('div');
            div.style.cssText = 'padding:8px; border-bottom:1px solid #eee; font-size:0.9rem;';
            div.innerHTML = `<span style="color:#4361ee;font-weight:bold;margin-right:5px;">#${idx+1}</span> ${escapeHtml(item.text)}`;
            elements.resultsContainer.appendChild(div);
        });

        // Code Generation
        generateCode();
    }

    function generateCode() {
        if (!state.results.length) { elements.outputPanel.style.display = 'none'; return; }
        elements.outputPanel.style.display = 'block';

        const pageWidth = elements.pdfCanvas.width / state.devicePixelRatio / state.zoom;
        const pageHeight = elements.pdfCanvas.height / state.devicePixelRatio / state.zoom;

        const htmlLines = state.results.map(item => {
            const t = escapeHtml(item.text);
            const b = item.box;
            // Tweak: Font size scaling for Sarabun to look "full" in the box
            const fontSize = Math.round(b.h * 0.82); 
            // Tweak: Slight Y offset to prevent clipping of upper vowels
            const top = b.y - (b.h * 0.05); 
            return `<div class="field" style="left:${b.x.toFixed(1)}px; top:${top.toFixed(1)}px; font-size:${fontSize}px;">${t}</div>`;
        }).join('\n');

        const css = `
            .page { position:relative; width:${pageWidth}px; height:${pageHeight}px; background:#fff; margin:20px auto; box-shadow:0 0 15px rgba(0,0,0,0.1); overflow:hidden; }
            .field { 
                position: absolute; 
                white-space: nowrap; 
                font-family: 'Sarabun', sans-serif; 
                line-height: 1.4; /* Crucial for Thai vowels */
                color: #000;
                transform-origin: top left;
                pointer-events: none;
            }`;

        const fullHtml = `<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <title>Exported PDF Data</title>
    <link href="https://fonts.googleapis.com/css2?family=Sarabun:wght@400;600&display=swap" rel="stylesheet">
    <style>body{background:#eee;}${css}</style>
</head>
<body>
    <div class="page">
${htmlLines}
    </div>
</body>
</html>`;

        elements.codeOutput.textContent = state.currentTab === 'html' ? htmlLines : fullHtml;
    }

    // --- Manual Selection (Mouse Events) ---
    let isDragging = false, startPos = {x:0,y:0};
    
    elements.methodManual.addEventListener('click', () => {
        state.isManualMode = !state.isManualMode;
        elements.methodManual.classList.toggle('active', state.isManualMode);
        elements.overlayCanvas.classList.toggle('drawing', state.isManualMode);
        showToast(state.isManualMode ? '‡πÇ‡∏´‡∏°‡∏î‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏≠‡∏á: ‡∏•‡∏≤‡∏Å‡∏Ñ‡∏•‡∏∏‡∏°‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°' : '‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡πÇ‡∏´‡∏°‡∏î‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏≠‡∏á', 'warning');
    });

    const getPos = (e) => {
        const rect = elements.overlayCanvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        return { x: clientX - rect.left, y: clientY - rect.top };
    }

    elements.overlayCanvas.addEventListener('mousedown', (e) => {
        if(!state.isManualMode) return;
        isDragging = true; startPos = getPos(e);
        state.manualSelection = { x:startPos.x, y:startPos.y, w:0, h:0 };
    });
    
    elements.overlayCanvas.addEventListener('mousemove', (e) => {
        if(!isDragging || !state.isManualMode) return;
        const curr = getPos(e);
        state.manualSelection = {
            x: Math.min(startPos.x, curr.x), y: Math.min(startPos.y, curr.y),
            w: Math.abs(curr.x - startPos.x), h: Math.abs(curr.y - startPos.y)
        };
        drawOverlay();
    });

    elements.overlayCanvas.addEventListener('mouseup', () => {
        if(!isDragging) return;
        isDragging = false;
        if(state.manualSelection.w > 5) {
            // Add to results
            const sel = state.manualSelection;
            const item = {
                text: "[Manual Selection]",
                box: { 
                    x: sel.x / state.zoom, y: sel.y / state.zoom, 
                    w: sel.w / state.zoom, h: sel.h / state.zoom 
                }
            };
            state.results.push(item);
            state.manualSelection = null;
            updateUIResults();
        }
    });

    // --- Footer Controls ---
    elements.prevPage.addEventListener('click', () => { if(state.currentPage>1) {state.currentPage--; elements.pageInput.value=state.currentPage; renderPage(state.currentPage);}});
    elements.nextPage.addEventListener('click', () => { if(state.currentPage<state.totalPages) {state.currentPage++; elements.pageInput.value=state.currentPage; renderPage(state.currentPage);}});
    
    // Zoom Logic
    elements.zoomRange.addEventListener('input', (e) => {
        state.zoom = parseInt(e.target.value)/100; 
        elements.zoomLevel.textContent = e.target.value+'%';
        // Debounce render
        if(state.renderTimer) clearTimeout(state.renderTimer);
        state.renderTimer = setTimeout(() => renderPage(state.currentPage), 200);
    });
    elements.zoomIn.addEventListener('click', () => { elements.zoomRange.value = parseInt(elements.zoomRange.value)+10; elements.zoomRange.dispatchEvent(new Event('input')); });
    elements.zoomOut.addEventListener('click', () => { elements.zoomRange.value = parseInt(elements.zoomRange.value)-10; elements.zoomRange.dispatchEvent(new Event('input')); });

    // Output Actions
    document.querySelectorAll('.tab').forEach(t => t.addEventListener('click', (e) => {
        document.querySelectorAll('.tab').forEach(x => x.classList.remove('active'));
        e.target.classList.add('active'); state.currentTab = e.target.dataset.tab; generateCode();
    }));
    elements.copyBtn.addEventListener('click', () => { navigator.clipboard.writeText(elements.codeOutput.textContent); showToast('‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡πÇ‡∏Ñ‡πâ‡∏î‡πÅ‡∏•‡πâ‡∏ß'); });
    elements.downloadBtn.addEventListener('click', () => {
        const blob = new Blob([elements.codeOutput.textContent], {type:'text/html'});
        const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'thai-export.html'; a.click();
    });

    </script>
</body>
</html>
